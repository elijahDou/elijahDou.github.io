---
layout: post
title: "BDD行为驱动开发"
description: ""
category: 
tags: [BDD, test, TDD]
---

#### 转载请注明出处：http://elijahdou.github.io/

### BDD（行为驱动开发）

#### 要想了解BDD（行为驱动开发）就先来说一下TDD。TDD（测试驱动开发）是敏捷开发的核心实践，基本思路就是通过测试来推动整个开发的进行，先把需求分析，设计，质量控制量化，根据需求排除模棱两可的需求，编写测试用例代码，然后根据测试用例编写产品代码，这就是所谓的TDD。

#### 相对于BDD，TDD的问题在于不知道应该测试些什么。


#### 什么叫行为：一个类对象的接口定义了其方法和依赖关系。这些方法和依赖定义类对象如何与应用的其他部分交互 以及该类对象的功能，这些就是对象的行为。


#### 测试的提示语句基本上能组成一句话，起到具体的提示作用

#### OC版本的BDD框架：Specta Kiwi Cedar 基于宏定义和block实现

#### swift版本的BDD框架：Sleipnir Quick



#### 可以使用category暴露内部的 未对外声明的方法

#### 我们应该注重代码的行为 而不是内部实现

#### BDD中的B怎么理解：开发者在编写测试代码的时候，要明确自己的定位，开发者是观察者，而类对象是被观察者，开发者要观察类对象的行为，这个行为包含两个方面：非互动行为 和 互动行为。非互动行为 就是不需要观察者与之互动就可以观察到的行为，可以理解为对象对自己施加的行为（可以理解为我们看到的它的长相，这是他自己打扮的结果）；互动行为 就是观察者给被观察者一个信号，被观察者回复一个应答。 以UI控件的测试为例，先测试非互动行为，这个UI控件应该长成什么样子（即根据需求设计的UI，如title color等）；然后是互动行为（如Button被点击的反应等）。  这些都来源于需求分析（我们需要对象有什么样的行为） 

#### 在BDD中，边界问题怎么测试

在TDD原则的指导下，我们先编写测试代码。这时因为还没有对应的产品代码，所以测试代码肯定是无法通过的。在大多数测试系统中，我们使用红色来表示错误，因此一个测试的初始状态应该是红色的。接下来我们需要使用最小的代价（最少的代码）来让测试通过。通过的测试将被表示为安全的绿色，于是我们回到了绿色的状态。接下来我们可以添加一些测试例，来验证我们的产品代码的实现是否正确。如果不幸新的测试例让我们回到了红色状态，那我们就可以修改产品代码，使其回到绿色。如此反复直到各种边界和测试都进行完毕，此时我们便可以得到一个具有测试保证，鲁棒性超强的产品代码。在我们之后的开发中，因为你有这些测试的保证，你可以大胆重构这段代码或者与之相关的代码，最后只需要保证项目处于绿灯状态，你就可以保证代码没重构没有出现问题。

简单说来，TDD的基本步骤就是“红→绿→大胆重构”。

#### OneV's Den[TDD的iOS开发初步以及Kiwi使用入门](http://onevcat.com/2014/02/ios-test-with-kiwi/)

#### [行为驱动开发](http://objccn.io/issue-15-1/)

#### [kiwi github地址](https://github.com/kiwi-bdd/Kiwi) 及其[wiki](https://github.com/kiwi-bdd/Kiwi/wiki)

#### [Kiwi 使用进阶 Mock, Stub, 参数捕获和异步测试](http://onevcat.com/2014/05/kiwi-mock-stub-test/)

一个典型的BDD的测试用例包活完整的三段式上下文，测试大多可以翻译为Given..When..Then的格式，读起来轻松惬意

一个Spec文件中可以包含多个describe（虽然我们很少这么做，一个测试文件应该专注于测试一个类）；一个describe可以包含多个context，来描述类在不同情景下的行为；一个context可以包含多个it的测试例。

#### 统一层级的it 是同级关系，之间不会相互影响，若其中操作了__block 或者 全局变量 有待验证


#### 高级的用法，包括模拟对象 (mock)，桩程序 (stub)，参数捕获和异步测试等内容

#### 测试的单一性

#### 对于 Kiwi 的 stub，需要注意的是它不是永久有效的，在每个 it block 的结尾 stub 都会被清空，超出范围的方法调用将不会被 stub 截取到。

#### 在 objc 的 OOP 中，类或者接口就是指导对象行为的蓝图，而 mock 则遵循这些蓝图并模拟它们的实例对象。从这方面来说，mock 与 stub 最大的区别在于 stub 只是简单的方法替换，而不涉及新的对象，被 stub 的对象可以是业务代码中真正的对象。而 mock 行为本身产生新的（不可能在业务代码中出现的）对象，并遵循类的定义相应某些方法。











